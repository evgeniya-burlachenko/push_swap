i   2 5 4 0 1 3
str 3 7 6 1 2 4

pushtobe: s m f в a
a: 1 4 7
b: 2 6 3
----------------------------------------------------
countSteps(a_arr, a_len( argc - 1) - кол -во чисел)
countSteps(b_arr, b_len)

пока есть цифры

arr_a[индекс порядковый].rr = порядковому индексу
и
arr[0].rrr = 0;
arr_a[1++].rrr = i-- (порядковый номер в обратном направлении)

итого

a_arr[0].rr = 0; 	a_arr[0].rrr = 0;
a_arr[1].rr = 1;	a_arr[1].rrr = 2;
a_arr[2].rr = 2;    a_arr[2].rrr = 1;


b_arr[0].rr = 0;	b_arr[0].rrr = 0;
b_arr[1].rr = 1;	b_arr[1].rrr = 2;
b_arr[2].rr = 2;	b_arr[2].rrr = 1;

--------------------------------------------------


-----------------------------------------------------------
numtopush (a_arr, b_arr, data, ret = malloc(4))

пока существует строка b_arr

rot = findPlacement(a_arr, b_arr[i].value, a_len)


-------------------------------------------------
findPlacement(a_arr, b_arr[i].value(2), a_len)

a: 1 4 7
b: 2 6 3

ret = malloc(2);

 ecли значение b < значения a[i++] и b больше a[ a_len -1]
1. 2 < 1 && 2 !> 7
пока есть a_arr
ecли b > значения a[i++] и b  < a[ i + 1]
2 > 1 && 2 < 7

i++; 

ret[0] = a_arr[порядковый номер++].rr;
ret[0] = a_arr[порядковый номер++].rrr;

итого

ret[0] = a_arr[1].rr = 1;
ret[1] = a_arr[1].rrr = 2;



------------------------------------------------
a: 1 4 7
b: 2 6 3

calculateSteps(b_arr, step = step[4], rot, i)

step[0] = new_max(rot[0], b_arr[i].rr);
step[0] = new_max(1, 0) //1

step[1] = new_max(rot[1], b_arr[i].rrr)
step[1] = new_max(2, 0);//2

step[2] = rot[1] + b_arr[i].rr
step[2] = 2 + 0 // 2

step[3] = rot[0] + b_arr[i].rrr
step[3] = 1 + 0 // 1

-------------------------------------------------
пока 0(j) < 4

если step < maxint(value)

value = step[j]
value = step[0] //1

ret[3] = j; //0

ret[2] = i //0

ret[0] = rot[0] //1

ret[1] = rot[1] //2


---------------------
step[1]
ret[3] = 1
ret[2] = 0
ret[0] = 1
ret[1] = 2

------------------
step[2]
ret[3] = 2
ret[2] = 0
ret[0] = 1
ret[1] = 2

-----------------
step[3]
ret[3] = 3
ret[2] = 0
ret[0] = 1
ret[1] = 2
--------------------------------------------------
--------------------------------------------------
i++
i=1
a: 1 4 7
b: 2 6 3

findPlacement(a_arr, b_arr[1].value(6), a_len(3))

если (6 < 1 && 6 > 7)
no
пока i(0) < 3
ecли (6 > 1 && 6 < 4)
no
ret[0] = 1





numtopush - 2 цикла по b и по 4 Steps

-------------------------------------------------
rotateStack(a_arr, b_arr, data, ret)

if(ret[3] == 0)
	rotate_0(a_arr, b_arr, data, int ret)
------------------------------------------------
1. rotate_0()
b_rr = b_arr[ret[2]].rr
b_rr = b_arr[0].rr
b_rr = 0

если ret[0] <= b_rr // 1!<=0 

тогда  ret[0] > b_rr
 1 > 0

 rotate_0_1(a_arr, b_arr, data, ret)

 пока  0 !> 0

 пока ret[0] > 0
	1 > 0
	ra(a_arr, data, 1)
повернуть a - сдвинуть вверх все элементы стека a на 1. 
Первый элемент становится последним.
	ret[0]--

a: 1 4 7 -> 4 7 1
b: 2 6 3
---------------------------------------
pa(a_arr, b_arr, data);
нажмите a - возьмите первый элемент в верхней части b и поместите его в верхнюю часть a.
Ничего не делайте, если b пуст.

a: 1 4 7 -> 2 4 7 1
b: 2 6 3 -> 6 3

-----------------2--------------------------
-------------------------------------------
2. 
countSteps(a_arr, a_len)
countSteps(b_arr, b_len)
a: 1 4 7 -> 2 4 7 1
b: 2 6 3 -> 6 3

пока 4(len) > 0(i)

a_arr[0].rr = 0;	a_arr[0].rrr = 0
a_arr[1].rr = 1;	a_arr[1].rrr = 3
a_arr[2].rr = 2;	a_arr[2].rrr = 2
a_arr[3].rr = 3;	a_arr[3].rrr = 1

b_arr[0].rr = 0;	b_arr[0].rrr = 0
b_arr[1].rr = 1;	b_arr[1].rrr = 2
b_arr[2].rr = 2; 	b_arr[2].rrr = 1

-----------------------------------------
2

findPlacement (arr, b_arr[i](1).value,a_len) 

a: 2 4 7 1
b: 6 3

 если (6 < a_arr[0].value ( 2) && 6 > a_arr[3].value (1))
 no 

 пока a_len

 если (6 > 2 && 6 < 4)
 no

 ret[0] = 1
 ret[1] = 3

 ----------------------------------------------
 2

 calculateSteps (b_arr, step [4], rot , 1)

 step[0] = new_max(1, 1)//1
 step[1] = new_max(3, 2)//3
 step[2] = 3 + 1 //4
 step[3] = 1 + 2 //3

 --------------
 пока j(0) < 4
если step [j] < 2147483647
























